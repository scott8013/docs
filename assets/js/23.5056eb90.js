(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{444:function(e,t,v){"use strict";v.r(t);var a=v(15),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"vue-面试题"}},[e._v("vue 面试题")]),e._v(" "),v("h2",{attrs:{id:"什么是mvvm"}},[e._v("什么是MVVM")]),e._v(" "),v("img",{staticClass:"zoom-imgs",attrs:{src:"https://github.com/scott8013/readme-images/blob/main/WX20210324-203950@2x.png?raw=true"}}),e._v("\n1.MVC 是一种软件架构模式, 传统的 MVC 指的是,用户操作会请求服务端路由，路由会调用对应的控制器来处理,控制器会获取数据。将结果返回给前端,页面重新渲染\n"),v("p",[e._v("2.MVVM :传统的前端会将数据手动渲染到页面上, MVVM 模式不需要用户收到操作 dom 元素,将数据绑 定到 viewModel 层上，会自动将数据渲染到页面中，视图变化会通知 viewModel层 更新数据。ViewModel\n就是我们 MVVM 模式中的桥梁.")]),e._v(" "),v("h2",{attrs:{id:"什么是mvvm-2"}},[e._v("什么是MVVM")]),e._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("MVVM最早由微软提出来，它借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离 把Model和View关联起来的就是ViewModel。\nViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model\nView 和 Model 之间的同步工作完全是自动的，无需人为干涉（由viewModel完成，在这里指VUE）\n因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br"),v("span",{staticClass:"line-number"},[e._v("4")]),v("br")])]),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("传统的 MVC 指的是,用户操作会请求服务端路由，路由会调用对应的控制器来处理,控制器会获取数 据。将结果返回给前端,页面重新渲染\nMVVM :传统的前端会将数据手动渲染到页面上, MVVM 模式不需要用户收到操作 dom 元素,将数据绑 定到 viewModel 层上，会自动将数据渲染到页面中，视图变化会通知 viewModel层 更新数据。\nViewModel 就是我们 MVVM 模式中的桥梁.\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br")])]),v("h2",{attrs:{id:"vue和react区别"}},[e._v("vue和react区别")]),e._v(" "),v("ul",[v("li",[v("h4",{attrs:{id:"_1-监听数据变化的方式不同。"}},[e._v("1.监听数据变化的方式不同。")]),e._v(" "),v("p",[e._v("vue 通过Object.definedProperty()数据劫持 和 发布和订阅模式， 能精确知道数据变化, 不需要特别的优化就能达到很好的性能 react 默认是通过比较引用的方式（diff）进行的，\n如果不优化可能会导致大量不必要的VDOM 重新渲染。 为什么react不精确监听数据变化呢？ 这是因为vue和react的设计理念上的区别， vue使用是可变数据， 而react强调的是数据的不可变， 两者没有好坏之分，\nvue更加简单， 而react构建大型应用的时候更加方便。 vue2.x版本对typescript支持不好。")])]),e._v(" "),v("li",[v("h4",{attrs:{id:"_2-数据流的不同"}},[e._v("2.数据流的不同")]),e._v(" "),v("p",[e._v("vue1.x版本可以实现两种双向绑定： 父子组件之间， props可以双向绑定 组件与DOM之间可以通过v-model（ v-model 是v-bind：value 和 v-on：input的语法糖）实现双向绑定。\nvue2.x版本去掉了第一种， 也就是父子组件不能实现双向绑定了。 并且vue2.x已经不鼓励组件对自己的props 进行任何修改了。 react 一直不支持双向绑定， 提倡的是单向数据流。 称之为\nonChange/setState模式。 不过由于我们一般都会用vuex 以及 redux 等单向数据流的状态管理框架， 因此很多时候我们感觉不到这一点的变化。")])]),e._v(" "),v("li",[v("h4",{attrs:{id:"_3-组件通信的区别"}},[e._v("3. 组件通信的区别")]),e._v(" "),v("p",[e._v("vue中有三种方式可以实现组件通信： 1.父组件通过props向子组件传递数据或者回调， 子组件通过$emit触发自定义事件传入参数 或者 调用callback传入参数把数据传给父组件。 2.evnet Bus 兄弟组件\n或者父子组件通信。 3. Provide/inject。 4.$parent/$child 5.$refs获取子组件实例。6.使用作用域插槽。\n[vue组件通讯8种方式]（https://juejin.cn/post/6844903887162310669）\nreact有3种方式可以实现组件通信：")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://blog.csdn.net/Charissa2017/article/details/105746685",target:"_blank",rel:"noopener noreferrer"}},[e._v("React 组件通信的五种方式_props_ref_Context_Redux"),v("OutboundLink")],1)])]),e._v(" "),v("li",[v("h4",{attrs:{id:"_4-vuex-和-redux-的区别"}},[e._v("4. Vuex 和 Redux 的区别")]),e._v(" "),v("p",[e._v("从表面上来说，store 注入和使用方式有一些区别。 在 Vuex 中，$store 被直接注入到了组件实例中，因此可以比较灵活的使用： 使用 dispatch 和 commit 提交更新 通过 mapState 或者直接通过\nthis.$store 来读取数据 在 Redux 中，我们每一个组件都需要显示的用 connect 把需要的 props 和 dispatch 连接起来。 另外 Vuex 更加灵活一些，组件中既可以 dispatch action\n也可以 commit updates，而 Redux 中只能进行 dispatch，并不能直接调用 reducer 进行修改。")]),e._v(" "),v("p",[e._v("从实现原理上来说，最大的区别是两点： Redux 使用的是不可变数据，而Vuex的数据是可变的。Redux每次都是用新的state替换旧的state，而Vuex是直接修改 Redux 在检测数据变化的时候，是通过 diff\n的方式比较差异的，而Vuex其实和Vue的原理一样，是通过 getter/setter来比较的（如果看Vuex源码会知道，其实他内部直接创建一个Vue实例用来跟踪数据变化） 而这两点的区别，其实也是因为 React 和\nVue的设计理念上的区别。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用React，小型项目用 Vue 的感觉。 …后续在补充")])])]),e._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/6844903668446134286",target:"_blank",rel:"noopener noreferrer"}},[e._v("React 和 Vue之间的区别"),v("OutboundLink")],1)]),e._v(" "),v("h2",{attrs:{id:"webpack-中-loader-和-plugin-的区别是什么"}},[e._v("webpack 中 loader 和 plugin 的区别是什么")]),e._v(" "),v("p",[e._v("loader：loader 是一个转换器，将 A 文件进行编译成 B 文件，属于单纯的文件转换过程")]),e._v(" "),v("p",[e._v("plugin：plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。")]),e._v(" "),v("h2",{attrs:{id:"vue-封装通用组件"}},[e._v("vue 封装通用组件")]),e._v(" "),v("p",[e._v("通用组件必须具备高性能、低耦合的特性")]),e._v(" "),v("p",[v("strong",[e._v("1、数据从父组件传入")])]),e._v(" "),v("ul",[v("li",[e._v("a.为了解耦，子组件本身就不能生成数据。即使生成了，也只能在组件内部运作，不能传递出去。")]),e._v(" "),v("li",[e._v("b.但是通用组件的的应用场景比较复杂，对 props 传递的参数应该添加一些验证规则")]),e._v(" "),v("li",[e._v("c.props中数据不要更改。")])]),e._v(" "),v("p",[v("strong",[e._v("2.在父组件处理事件")])]),e._v(" "),v("ul",[v("li",[e._v("a.在通用组件中，通常会需要有各种事件， 比如复选框的 change 事件，或者组件中某个按钮的 click 事件 这些事件的处理方法应当尽量放到父组件中，通用组件本身只作为一个中转,\n这样既降低了耦合性，也保证了通用组件中的数据不被污染")]),e._v(" "),v("li",[e._v("b. 不过，并不是所有的事件都放到父组件处理 比如组件内部的一些交互行为，或者处理的数据只在组件内部传递，这时候就不需要用 $emit 了")])]),e._v(" "),v("p",[v("strong",[e._v("3. 合理使用slot")]),e._v("\n一般在不同场景显示不同组件。")]),e._v(" "),v("p",[v("strong",[e._v("4.尽量不要依赖vuex")])]),e._v(" "),v("p",[e._v("Vue 没有直接子对子传参的方法，建议将需要传递数据的子组件，都合并为一个组件。如果一定需要子对子传参，可以先从传到父组件，再传到子组件。 或者使用pubSub.js实现子组件之间互相传参数。")]),e._v(" "),v("p",[v("strong",[e._v("5.动态组件")]),e._v("\nVue 还可以将多个子组件，都挂载在同一个位置，通过变量来切换组件，实现 tab 菜单这样的效果")]),e._v(" "),v("div",{staticClass:"language-js line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("component v"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("bind"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("is"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'tabView'")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),e._v("component"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("p",[v("strong",[e._v("6.递归组件")]),e._v("\n当组件拥有 name 属性的时候，就可以在它的模板内递归的调用自己，这在开发树形组件的时候十分有效")]),e._v(" "),v("h2",{attrs:{id:"vue数据双向绑定原理"}},[e._v("vue数据双向绑定原理")]),e._v(" "),v("p",[e._v("双向绑定是指数据模型（Module）和 视图（View）之间的双向绑定。 其原理是采用数据劫持结合发布订阅者模式实现。")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("1). 创建vue实例的过程中， 会先遍历data选项中所有的属性（发布者）， 用Object.defineProperty劫持这些属性将其转换为getter/setter。读取数据时候会触发getter， 修改数据会触发setter。")]),e._v(" "),v("p",[e._v("代码：")]),e._v(" "),v("ul",[v("li",[e._v("1).initData 初始化用户传入的数据")]),e._v(" "),v("li",[e._v("2). new Observer 将数据进行观测。")]),e._v(" "),v("li",[e._v("3). this.walk 进行对象的处理。")]),e._v(" "),v("li",[e._v("4). defineReactive 循环对象属性定义响应式变化。")]),e._v(" "),v("li",[e._v("5). Object.defineProperty 使用Object.defineProperty 重新定义数据。 拦截属性的获取--进行依赖收集。 拦截属性的更新操作， 对相关依赖进行通知。")])])]),e._v(" "),v("li",[v("p",[e._v("2). 然后给每个对象属性对应的new Dep(), Dep 专门收集依赖、删除依赖、向依赖发送消息。 dep 实际就是一个普通对象， 里边只有两个属性id,subs。 subs存放watcher数组。\n先把每个依赖设置在Dep.target上。 在Dep中创建一个依赖数组， 先判断Dep.target是否已经在依赖数组中存在， 如果不存在就添加到依赖数组中完成依赖收集。 随后Dep.target 置为null。")])]),e._v(" "),v("li",[v("p",[e._v("3). 组件在挂载过程中都会new 一个 Watcher实例。 这个实例就是依赖（订阅者）。 Watcher的第二个参数是一个函数， 此函数的作用是更新渲染节点。 在首次渲染过程， 会自动调用Dep方法收集依赖，\n收集完成后组件中每个数据都绑定上依赖。 当数据变化时就会在setter中调用 dep.notify 通知对应的依赖进行更新。 在更新过程中要读取数据， 就会触发Watcher的第二个函数参数。 一触发就再次自动调用Dep方法收集依赖，\n同时在此函数中运行patch（diff 运算）来更新对应的DOM节点， 完成了数据的双向绑定。")])])]),e._v(" "),v("h2",{attrs:{id:"mixin-合并规则"}},[e._v("mixin 合并规则")]),e._v(" "),v("h3",{attrs:{id:"选项合并规则"}},[e._v("选项合并规则")]),e._v(" "),v("p",[e._v("1.数据对象（data）在内部会进行递归合并，并在发生冲突时以组件数据优先")]),e._v(" "),v("p",[e._v("2.同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用")]),e._v(" "),v("p",[e._v("3.值为对象的选项，例如 methods、components、watch 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。Vue.extend() 也使用同样的策略进行合并")]),e._v(" "),v("h2",{attrs:{id:"elementui-按需加载原理"}},[e._v("elementUI 按需加载原理")]),e._v(" "),v("p",[e._v("。。。")]),e._v(" "),v("h2",{attrs:{id:"图片懒加载原理"}},[e._v("图片懒加载原理")]),e._v(" "),v("p",[e._v("图片懒加载考虑哪些问题，实现的大概逻辑")]),e._v(" "),v("h2",{attrs:{id:"统计页面停留时长"}},[e._v("统计页面停留时长")]),e._v(" "),v("p",[e._v("统计用户访问时长，如何优雅地发送统计数据到服务端（提示： 提出在路由钩子实现， 提到节流和防抖， 回答节流和防抖的原理）")]),e._v(" "),v("h2",{attrs:{id:"keep-alive-原理"}},[e._v("keep alive 原理")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1605603",target:"_blank",rel:"noopener noreferrer"}},[e._v("keep alive原理"),v("OutboundLink")],1),e._v(" "),v("a",{attrs:{href:"https://github.com/answershuto/learnVue/blob/master/docs/%E8%81%8A%E8%81%8Akeep-alive%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.MarkDown",target:"_blank",rel:"noopener noreferrer"}},[e._v(" keep alive 原理"),v("OutboundLink")],1)]),e._v(" "),v("h2",{attrs:{id:"vue-template模板到解析层真实dom的过程"}},[e._v("vue template模板到解析层真实DOM的过程")]),e._v(" "),v("h2",{attrs:{id:"v-model手动实现"}},[e._v("v-model手动实现")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://segmentfault.com/a/1190000012264050",target:"_blank",rel:"noopener noreferrer"}},[e._v("v-model手动实现"),v("OutboundLink")],1)]),e._v(" "),v("h2",{attrs:{id:"nexttick-原理"}},[e._v("$nextTick 原理")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://ustbhuangyi.github.io/vue-analysis/v2/reactive/next-tick.html#js-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6",target:"_blank",rel:"noopener noreferrer"}},[e._v("nextTick原理 黄奕"),v("OutboundLink")],1)]),e._v(" "),v("p",[v("a",{attrs:{href:"https://bbs.huaweicloud.com/blogs/235688",target:"_blank",rel:"noopener noreferrer"}},[e._v("nextTick原理 华为云"),v("OutboundLink")],1)]),e._v(" "),v("h2",{attrs:{id:"vuex原理"}},[e._v("vuex原理")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://segmentfault.com/a/1190000018251844",target:"_blank",rel:"noopener noreferrer"}},[e._v("vuex原理"),v("OutboundLink")],1)]),e._v(" "),v("h2",{attrs:{id:"vue-router原理"}},[e._v("vue router原理")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/6844903612930326541",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue Router"),v("OutboundLink")],1)]),e._v(" "),v("h2",{attrs:{id:"v-if-和-v-show区别"}},[e._v("v-if 和 v-show区别")]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("相同点 两者都是在判断DOM节点是否要显示。")])]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),v("p",[e._v("不同点\n1、实现方式")]),e._v(" "),v("p",[e._v("v-if是根据后面数据的真假值判断直接从Dom树上删除或重建元素节点")]),e._v(" "),v("p",[e._v("v-show只是在修改元素的css样式，也就是display的属性值，元素始终在Dom树上。")]),e._v(" "),v("p",[e._v("2、编译过程")]),e._v(" "),v("p",[e._v("v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件")]),e._v(" "),v("p",[e._v("v-show只是简单的基于css切换")]),e._v(" "),v("p",[e._v("3、编译条件")]),e._v(" "),v("p",[e._v("v-if是惰性的，如果初始条件为假，则什么也不做只有在条件第一次变为真时才开始局部编译")]),e._v(" "),v("p",[e._v("v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素始终被保留")]),e._v(" "),v("p",[e._v("4、性能消耗")]),e._v(" "),v("p",[e._v("v-if有更高的切换消耗，不适合做频繁的切换")]),e._v(" "),v("p",[e._v("v-show有更高的初始渲染消耗，适合做频繁的额切换")])]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("v-if vs v-show v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建")]),e._v(" "),v("p",[e._v("也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。")]),e._v(" "),v("p",[e._v("v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景 v-show\n则适用于需要非常频繁切换条件的场景")])]),e._v(" "),v("h2",{attrs:{id:"vue开发插件流程"}},[e._v("vue开发插件流程")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://segmentfault.com/a/1190000010813937",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue自定义插件"),v("OutboundLink")],1)]),e._v(" "),v("h2",{attrs:{id:"computed-与-watch区别"}},[e._v("computed 与 watch区别")]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("功能上：computed是计算属性，也就是依赖其它的属性计算所得出最后的值。watch是去监听一个值的变化，然后执行相对应的函数")]),e._v(" "),v("p",[e._v("使用上：computed中的函数必须要用return返回 watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作，不是必须要用return")]),e._v(" "),v("p",[e._v("性能上：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调")]),e._v(" "),v("p",[e._v("场景上：computed：当一个属性受多个属性影响的时候，例子：购物车商品结算 watch：当一条数据影响多条数据的时候，例子：搜索框")])]),e._v(" "),v("h2",{attrs:{id:"vue-router相关问题待补充"}},[e._v("vue router相关问题待补充")]),e._v(" "),v("h2",{attrs:{id:"分片下载与上传文件-如何实现"}},[e._v("分片下载与上传文件 如何实现")]),e._v(" "),v("h2",{attrs:{id:"vue-diff-算法"}},[e._v("vue diff 算法")]),e._v(" "),v("h2",{attrs:{id:"vue模板编译过程"}},[e._v("vue模板编译过程")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://segmentfault.com/a/1190000012922342",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue模板编译过程"),v("OutboundLink")],1)]),e._v(" "),v("h2",{attrs:{id:"vue组建name属性的作用"}},[e._v("vue组建name属性的作用")]),e._v(" "),v("p",[e._v("项目使用keep-alive时，可以搭配组件的name属性进行过滤\nDOM做递归组件时需要调用自身name\nvue-devtools 调试工具里显示的组见名称是由vue中组件name决定的")]),e._v(" "),v("h2",{attrs:{id:"keep-alive-原理loader-loader-是一个转换器-将-a-文件进行编译成-b-文件-属于单纯的文件转换过程"}},[e._v("keep-alive 原理loader：loader 是一个转换器，将 A 文件进行编译成 B 文件，属于单纯的文件转换过程；")]),e._v(" "),v("p",[e._v("plugin：plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。\nkeep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染\n一般结合路由和动态组件一起使用，用于缓存组件\n提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高\n对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated")]),e._v(" "),v("h2",{attrs:{id:"vue父子组建传递参数-8种方式"}},[e._v("vue父子组建传递参数 8种方式")]),e._v(" "),v("blockquote",[v("p",[e._v("参考地址： https://juejin.cn/post/6844904080540712967")])]),e._v(" "),v("h2",{attrs:{id:"组建化-和-mvvm"}},[e._v("组建化 和 MVVM")]),e._v(" "),v("blockquote",[v("p",[e._v("1.1组件：把重复的代码提取出来合并成为一个个组件，组件最重要的就是重用（复用），位于框架最底层，其他功能都依赖于组件，可供不同功能使用，独立性强。")])]),e._v(" "),v("blockquote",[v("p",[e._v("1.2模块：分属同一功能/业务的代码进行隔离（分装）成独立的模块，可以独立运行，以页面、功能或其他不同粒度划分程度不同的模块，位于业务框架层，模块间通过接口调用，目的是降低模块间的耦合，由之前的主应用与模块耦合，变为主应用与接口耦合，接口与模块耦合。")])]),e._v(" "),v("h3",{attrs:{id:"eg"}},[e._v("eg:")]),e._v(" "),v("blockquote",[v("p",[e._v("2.1组件：就像一个个小的单位，多个组件可以组合成组件库，方便调用和复用，组件间也可以嵌套，小组件组合成大组件。\n2.2模块：就像是独立的功能和项目（如淘宝：注册、登录、购物、直播...），可以调用组件来组成模块，多个模块可以组合成业务框架。")])]),e._v(" "),v("h2",{attrs:{id:"响应式原理"}},[e._v("响应式原理")]),e._v(" "),v("h2",{attrs:{id:"vdom-和-diff"}},[e._v("vdom 和 diff")]),e._v(" "),v("h2",{attrs:{id:"模板编译"}},[e._v("模板编译")]),e._v(" "),v("h2",{attrs:{id:"组建渲染过程"}},[e._v("组建渲染过程")]),e._v(" "),v("h2",{attrs:{id:"前端路由"}},[e._v("前端路由")])])}),[],!1,null,null,null);t.default=r.exports}}]);